"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const botbuilder_1 = require("botbuilder");
const botframework_connector_1 = require("botframework-connector");
const qs_1 = require("qs");
// Constants taken from BotFrameworkAdapter.ts
const OAUTH_ENDPOINT = 'https://api.botframework.com';
const US_GOV_OAUTH_ENDPOINT = 'https://api.botframework.azure.us';
const botFrameworkAdapter_1 = require("botbuilder/lib/botFrameworkAdapter");
/**
 * Adds helper functions to the default BotAdapter
 */
class CustomWebAdapter extends botbuilder_1.BotAdapter {
    /**
     * Creates a new CustomWebAdapter instance.
     * @param botFrameworkAdapterSettings configuration settings for the adapter.
     */
    constructor(botFrameworkAdapterSettings) {
        var _a;
        super();
        /**
         * Workaround for [ABS OAuth cards](https://github.com/microsoft/botbuilder-js/pull/1812)
         */
        this.name = 'Web Adapter';
        this.TokenApiClientCredentialsKey = Symbol('TokenApiClientCredentials');
        this.oAuthSettings = botFrameworkAdapterSettings;
        if ((_a = this.oAuthSettings) === null || _a === void 0 ? void 0 : _a.appId) {
            this.credentials = new botframework_connector_1.MicrosoftAppCredentials(this.oAuthSettings.appId, this.oAuthSettings.appPassword || '', this.oAuthSettings.channelAuthTenant);
            this.credentialsProvider = new botframework_connector_1.SimpleCredentialProvider(this.credentials.appId, this.oAuthSettings.appPassword || '');
        }
    }
    /**
     * Retrieve body from WebRequest
     * Works with Express & Restify
     * @protected
     * @param req incoming web request
     */
    retrieveBody(req) {
        const contentType = req.headers['content-type'] || req.headers['Content-Type'];
        return new Promise((resolve, reject) => {
            if (req.body) {
                try {
                    resolve(req.body);
                }
                catch (err) {
                    reject(err);
                }
            }
            else {
                let requestData = '';
                req.on('data', (chunk) => {
                    requestData += chunk;
                });
                req.on('end', () => {
                    try {
                        if (contentType === null || contentType === void 0 ? void 0 : contentType.includes('application/x-www-form-urlencoded')) {
                            req.body = qs_1.parse(requestData);
                        }
                        else {
                            req.body = JSON.parse(requestData);
                        }
                        resolve(req.body);
                    }
                    catch (err) {
                        reject(err);
                    }
                });
            }
        });
    }
    /**
     * Copied from `BotFrameworkAdapter.ts` to support { type: 'delay' } activity.
     * @param timeout timeout in milliseconds
     * @default 1000
     */
    delay(timeout) {
        timeout = (typeof timeout === 'number' ? timeout : 1000);
        return new Promise((resolve) => {
            setTimeout(resolve, timeout);
        });
    }
    getUserToken(context, connectionName, magicCode, oAuthAppCredentials) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!context.activity.from || !context.activity.from.id) {
                throw new Error(`CustomWebAdapter.getUserToken(): missing from or from.id`);
            }
            if (!connectionName) {
                throw new Error('getUserToken() requires a connectionName but none was provided.');
            }
            const userId = context.activity.from.id;
            const url = this.oauthApiUrl(context);
            const client = this.createTokenApiClient(url, oAuthAppCredentials);
            context.turnState.set(this.TokenApiClientCredentialsKey, client);
            const result = yield client.userToken.getToken(userId, connectionName, { code: magicCode, channelId: context.activity.channelId });
            if (!result || !result.token || result._response.status == 404) {
                return undefined;
            }
            else {
                return result;
            }
        });
    }
    signOutUser(context, connectionName, userId, oAuthAppCredentials) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!context.activity.from || !context.activity.from.id) {
                throw new Error(`CustomWebAdapter.signOutUser(): missing from or from.id`);
            }
            if (!userId) {
                userId = context.activity.from.id;
            }
            const url = this.oauthApiUrl(context);
            const client = this.createTokenApiClient(url, oAuthAppCredentials);
            context.turnState.set(this.TokenApiClientCredentialsKey, client);
            yield client.userToken.signOut(userId, { connectionName: connectionName, channelId: context.activity.channelId });
        });
    }
    /**
     * Asynchronously gets a sign-in link from the token server that can be sent as part
     * of a [SigninCard](xref:botframework-schema.SigninCard).
     *
     * @param context The context object for the turn.
     * @param connectionName The name of the auth connection to use.
     * @param oAuthAppCredentials AppCredentials for OAuth.
     * @param userId The user id that will be associated with the token.
     * @param finalRedirect The final URL that the OAuth flow will redirect to.
     */
    getSignInLink(context, connectionName, oAuthAppCredentials, userId, finalRedirect) {
        return __awaiter(this, void 0, void 0, function* () {
            if (userId && userId != context.activity.from.id) {
                throw new ReferenceError(`cannot retrieve OAuth signin link for a user that's different from the conversation`);
            }
            const conversation = botbuilder_1.TurnContext.getConversationReference(context.activity);
            const url = this.oauthApiUrl(context);
            const client = this.createTokenApiClient(url, oAuthAppCredentials);
            context.turnState.set(this.TokenApiClientCredentialsKey, client);
            const state = {
                ConnectionName: connectionName,
                Conversation: conversation,
                MsAppId: client.credentials.appId,
                RelatesTo: context.activity.relatesTo
            };
            const finalState = Buffer.from(JSON.stringify(state)).toString('base64');
            return (yield client.botSignIn.getSignInUrl(finalState, { channelId: context.activity.channelId, finalRedirect }))._response.bodyAsText;
        });
    }
    getTokenStatus(context, userId, includeFilter, oAuthAppCredentials) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!userId && (!context.activity.from || !context.activity.from.id)) {
                throw new Error(`CustomWebAdapter.getTokenStatus(): missing from or from.id`);
            }
            userId = userId || context.activity.from.id;
            const url = this.oauthApiUrl(context);
            const client = this.createTokenApiClient(url, oAuthAppCredentials);
            context.turnState.set(this.TokenApiClientCredentialsKey, client);
            return (yield client.userToken.getTokenStatus(userId, { channelId: context.activity.channelId, include: includeFilter }))._response.parsedBody;
        });
    }
    getAadTokens(context, connectionName, resourceUrls, oAuthAppCredentials) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!context.activity.from || !context.activity.from.id) {
                throw new Error(`CustomWebAdapter.getAadTokens(): missing from or from.id`);
            }
            const userId = context.activity.from.id;
            const url = this.oauthApiUrl(context);
            const client = this.createTokenApiClient(url, oAuthAppCredentials);
            context.turnState.set(this.TokenApiClientCredentialsKey, client);
            return (yield client.userToken.getAadTokens(userId, connectionName, { resourceUrls: resourceUrls }, { channelId: context.activity.channelId }))._response.parsedBody;
        });
    }
    /**
     * Asynchronously Get the raw signin resource to be sent to the user for signin.
     *
     * @param context The context object for the turn.
     * @param connectionName The name of the auth connection to use.
     * @param userId The user id that will be associated with the token.
     * @param finalRedirect The final URL that the OAuth flow will redirect to.
     *
     * @returns The [BotSignInGetSignInResourceResponse](xref:botframework-connector.BotSignInGetSignInResourceResponse) object.
     */
    getSignInResource(context, connectionName, userId, finalRedirect, appCredentials) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!connectionName) {
                throw new Error('getUserToken() requires a connectionName but none was provided.');
            }
            if (!context.activity.from || !context.activity.from.id) {
                throw new Error(`CustomWebAdapter.getSignInResource(): missing from or from.id`);
            }
            // what to do when userId is null (same for finalRedirect)
            if (userId && context.activity.from.id != userId) {
                throw new Error('CustomWebAdapter.getSiginInResource(): cannot get signin resource for a user that is different from the conversation');
            }
            const url = this.oauthApiUrl(context);
            const client = this.createTokenApiClient(url, appCredentials);
            const conversation = botbuilder_1.TurnContext.getConversationReference(context.activity);
            const state = {
                ConnectionName: connectionName,
                Conversation: conversation,
                relatesTo: context.activity.relatesTo,
                MSAppId: client.credentials.appId
            };
            const finalState = Buffer.from(JSON.stringify(state)).toString('base64');
            const options = { finalRedirect: finalRedirect };
            return yield (client.botSignIn.getSignInResource(finalState, options));
        });
    }
    /**
     * Asynchronously Performs a token exchange operation such as for single sign-on.
     * @param context Context for the current turn of conversation with the user.
     * @param connectionName Name of the auth connection to use.
     * @param userId The user id that will be associated with the token.
     * @param tokenExchangeRequest The exchange request details, either a token to exchange or a uri to exchange.
     */
    exchangeToken(context, connectionName, userId, tokenExchangeRequest, appCredentials) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!connectionName) {
                throw new Error('exchangeToken() requires a connectionName but none was provided.');
            }
            if (!userId) {
                throw new Error('exchangeToken() requires an userId but none was provided.');
            }
            if (tokenExchangeRequest && !tokenExchangeRequest.token && !tokenExchangeRequest.uri) {
                throw new Error('CustomWebAdapter.exchangeToken(): Either a Token or Uri property is required on the TokenExchangeRequest');
            }
            const url = this.oauthApiUrl(context);
            const client = this.createTokenApiClient(url, appCredentials);
            return (yield client.userToken.exchangeAsync(userId, connectionName, context.activity.channelId, tokenExchangeRequest))._response.parsedBody;
        });
    }
    /**
     * Creates an OAuth API client.
     *
     * @param serviceUrl The client's service URL.
     * @param oAuthAppCredentials AppCredentials for OAuth.
     *
     * @remarks
     * Override this in a derived class to create a mock OAuth API client for unit testing.
     */
    createTokenApiClient(serviceUrl, oAuthAppCredentials) {
        const tokenApiClientCredentials = oAuthAppCredentials ? oAuthAppCredentials : this.credentials;
        const client = new botframework_connector_1.TokenApiClient(tokenApiClientCredentials, { baseUri: serviceUrl, userAgent: botFrameworkAdapter_1.USER_AGENT });
        return client;
    }
    /**
     * Gets the OAuth API endpoint.
     *
     * @param contextOrServiceUrl The URL of the channel server to query or
     * a [TurnContext](xref:botbuilder-core.TurnContext). For a turn context, the context's
     * [activity](xref:botbuilder-core.TurnContext.activity).[serviceUrl](xref:botframework-schema.Activity.serviceUrl)
     * is used for the URL.
     *
     * @remarks
     * Override this in a derived class to create a mock OAuth API endpoint for unit testing.
     */
    oauthApiUrl(contextOrServiceUrl) {
        const isEmulatingOAuthCards = false;
        return isEmulatingOAuthCards ?
            (typeof contextOrServiceUrl === 'object' ? contextOrServiceUrl.activity.serviceUrl : contextOrServiceUrl) :
            (this.oAuthSettings.oAuthEndpoint ? this.oAuthSettings.oAuthEndpoint :
                botframework_connector_1.JwtTokenValidation.isGovernment(this.oAuthSettings.channelService) ?
                    US_GOV_OAUTH_ENDPOINT : OAUTH_ENDPOINT);
    }
}
exports.CustomWebAdapter = CustomWebAdapter;
//# sourceMappingURL=customWebAdapter.js.map